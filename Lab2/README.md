## Αναφορά Δεύτερου Εργαστηρίου
### Αρχιτεκτονική Υπολογιστών

* Σε αυτήν την άσκηση γίνεται προσομοίωση των [SPEC CPU2006 Benchmarks](https://www.spec.org/cpu2006/) στο [gem5](https://www.gem5.org). 

* Συγκεκριμένα, προσομοιώνονται τα: **401.bzip2**, **429.mcf**, **458.sjeng**, **470.lbm** και **456.hmmer** για διάφορες τιμές συχνότητας επεξεργαστή και διαφορετικές αρχιτεκτονικές μνήμης.

* Έπειτα, γίνεται μία προσπάθεια για βελτιστοποίηση της επιλογής της αρχιτεκτονικής μνήμης για κάθε _Benchmark_, με αξιοποίηση των στατιστικών από τις προσομοιώσεις στο gem5 και πληροφοριών από την βιβλιογραφία. 

* Τέλος, δημιουργείται μία συνάρτηση κόστους για τις επιλογές του παραπάνω βήματος.  


## Βήμα 1
1. Tα **default** στοιχεία του επεξεργαστή βρέθηκαν στο αρχείο _config.ini_ της κάθε προσομοίωσης.
**Συγκεκριμένα:**

* **dcache** από το system.cpu.dcache.
```
size=65536
assoc=2
```
* **icache** από το system.cpu.icache.
```
size=32768
assoc=2
```
* **l2cache** από το system.l2.
```
size=2097152
assoc=8
```
* **cache line size** από το system.
```
cache_line_size=64
```

2. Καταγραφή αποτελεσμάτων benchmarks για **default** τιμές (2GHz cpu-clock).

|                       |   bzip  |   mcf  |  hmmer |  sjeng  |   libm  |
|:---------------------:|:-------:|:------:|:------:|:-------:|:-------:|
| system.cpu.cpi        |  1.679650 | 1.299095 | 1.187917 | 10.270554 |  3.4934 |
| sim_seconds           |  0.083982 | 0.064955 | 0.059396 | 0.513528 | 0.174671 |
| system.cpu.dcache.overall_miss_rate::total | 0.014798 | 0.002108 | 0.001637 |  0.121831 | 0.060972 |
|system.cpu.icache.overall_miss_rate::total |  0.000077 | 0.023612 | 0.000221 | 0.000020 | 0.000094 |
| system.l2.overall_miss_rate::total| 0.282163 | 0.055046 | 0.077760 | 0.999972 | 0.999944 |  

Παρακάτω φαίνονται τα στοιχεία αυτού του πίνακα στα ακόλουθα διαγράμματα:


![alt text](https://github.com/DimKon2001/ArchLab/blob/main/Lab2/plots/dl1.jpg)
![alt text](https://github.com/DimKon2001/ArchLab/blob/main/Lab2/plots/il1.jpg)
![alt text](https://github.com/DimKon2001/ArchLab/blob/main/Lab2/plots/L2.jpg)
![alt text](https://github.com/DimKon2001/ArchLab/blob/main/Lab2/plots/secs.jpg)
![alt text](https://github.com/DimKon2001/ArchLab/blob/main/Lab2/plots/cpi-def.jpg)

* Παρατηρούμε ότι το CPI και τα simulated_seconds ακολουθούν το ίδιο μοτίβο, αναμενόμενο, καθώς είναι και τα δύο μέτρο απόδοσης και εφόσον συγκρίνονται υπό όμοια συχνότητα ρολογίου, αναμένεται να έχουν την ίδια συμπεριφορά. Επίσης, τα misses στην data cache φαίνεται να ακολουθούν και αυτά το ίδιο μοτίβο, κατί που εξηγείται καθώς διαδραματίζουν σημαντικό ρόλο στην επίδοση του συστήματος. Ακόμα, τα misses της L2 φαίνεται να είναι σε υψηλά σχετικά ποσοστά, όμως δεν θα πρέπει να ξεχνάμε ότι ένα μικρό ποσοστό των προσπελάσεων της μνήμης καταλήγουν σε αυτό το επίπεδο cache, όπως φαίνεται και από το miss rate της L1 Data και Instruction Cache. Τέλος, όλα σχεδόν τα προγράμματα έχουν αμελητέο instruction cache miss rate, εκτός από ένα. Αυτό, μπορεί να οφείλεται στο γεγονός ότι τα πιο πολλά προγράμματα περιέχουν λούπες και έτσι επαναλμβάνουν τις ίδιες εντολές είτε στο γεγονός ότι απουσιάζουν εντολές branch, με αποτέλεσμα να μην διακόπτεται η ροή της εκτέλεσης.  

3. 

* Mε αλλαγή της συχνότητας του επεξεργαστή στο **1 GHz.**

|                       |   bzip  |   mcf  |  hmmer |  sjeng  |   libm  |
|:---------------------:|:-------:|:------:|:------:|:-------:|:-------:|
| system.cpu.cpi        |  1.610247 | 1.279422 | 1.185304 | 7.040561 |  2.623265 |
| sim_seconds           |  0.161025 | 0.12794 | 0.118530 | 0.704056 | 0.262327 |
| system.cpu.dcache.overall_miss_rate::total | 0.014675 | 0.002108 | 0.001629 |  0.121831 | 0.060971 |
|system.cpu.icache.overall_miss_rate::total |  0.000077 | 0.023627 | 0.000221 | 0.000020 |  0.000094 |
| system.l2.overall_miss_rate::total| 0.282157 | 0.055046 | 0.077747 | 0.999972 | 0.999944 |

* Mε αλλαγή της συχνότητας του επεξεργαστή στα **3 GHz.**

|                       |   bzip  |   mcf  |  hmmer |  sjeng  |   libm  |
|:---------------------:|:-------:|:------:|:------:|:-------:|:-------:|
| system.cpu.cpi        |  1.753291 | 1.317329 | 1.190581 | 13.508136 |  4.39737 |
| sim_seconds           |  0.058385 | 0.043867 | 0.039646 | 0.449821 |  0.146433 |
| system.cpu.dcache.overall_miss_rate::total |  0.014932 | 0.002108 | 0.001637 | 0.121831 |  0.060972 |
|system.cpu.icache.overall_miss_rate::total |  0.000077 | 0.023609 | 0.000221 | 0.000020 | 0.000094 |
| system.l2.overall_miss_rate::total| 0.282166 | 0.055046 | 0.077761 | 0.999972 | 0.999944 |

* Το είναι το ρολόι που χρησιμοποιούν τα blocks που τρέχουν με τη συχνότητα του επεξεργαστή, ενώ το είναι το ρολόι που χρησιμοποιούν τα blocks που τρέχουν με την ταχύτητα του συστήματος. Ο λόγος ύπαρξης δύο ρολογιών είναι για λόγους συγχρονισμού των πιο γρήγορων τμημάτων του συστήματος (επεξεργαστής) με τα πιο αργά (π.χ. μνήμες).
_Πηγή_: [https://www.gem5.org/documentation/learning_gem5/part1/example_configs/](https://www.gem5.org/documentation/learning_gem5/part1/example_configs/)

* Πράγματι, αναζητώντας στο _congig.json_ πληροφορίες για το clock, βλέπουμε ότι τόσο οι πυρήνες, όσο και οι caches χρονίζονται στο cpu_clock ενώ η μνήμη DRAM στο system_clock.

* Τέλος, παρατηρώντας τα αποτελέσματα για κάθε benchmark, βλέπουμε ότι αυξάνοντας τη συχνότητα του επεξεργαστή, υπάρχει μείωση του χρόνου εκτέλεσης των προγραμμάτων αλλά όχι με γραμμικό scaling. Δηλαδή από τα 1 στα 2 GHz η αύξηση της ταχύτητας είναι μεγαλύτερη από ότι από τα 2 στα 3 GHz. Αυτό μπορεί να συμβαίνει επειδή η ύπαρξη και του ρολογιού του συστήματος καθιστά αδύνατο η μνήμη να μπορεί να ακολουθήσει τη ταχύτητα του επεξεργαστή, με αποτέλεσμα κάθε φορά που χρειάζεται να την προσπελαύνουμε να χάνουμε τον ίδιο χρόνο ανεξαρτήτως cpu_clock. Έτσι, η αύξηση της συχνότητας του επεξεργαστή βελτιώνει την απόδοση, αλλά πιθανόν να οδηγεί σε κορεσμό από μία συχνότητα και μετά. 

4.

* Mε αλλαγή της μνήμης DRAM σε **DDR3_2133_8x8**

|                       |   bzip  |   mcf  |  hmmer |  sjeng  |   libm  |
|:---------------------:|:-------:|:------:|:------:|:-------:|:-------:|
| system.cpu.cpi        |  1.672175 | 1.299095 | 1.187722 | 9.862562 |  3.430593 |
| sim_seconds           | 0.083609 | 0.064955 | 0.059386 | 0.493128 | 0.171530 |
| system.cpu.dcache.overall_miss_rate::total |  0.014795 | 0.002108 | 0.001637 |  0.121831 |  0.060972 |
|system.cpu.icache.overall_miss_rate::total |  0.000077 | 0.023612 | 0.000221 | 0.000020 |  0.000094 |
| system.l2.overall_miss_rate::total| 0.282159 | 0.055046 | 0.077760 | 0.999972 | 0.999944 | 

* Παρατηρούμε μία ελάχιστη μείωση του χρόνου εκτέλεσης των προγραμμάτων με την αύξηση του ρολογιού της μνήμης. Η βελτίωση είναι μικρή καθώς μόνο ένα μικρό ποσοστό των προσπελάσεων καταλήγουν στην μνήμη RAM (μόνο τα L2 misses). Έτσι, διακρίνουμε ότι τα benchmarks που έχουν μεγαλύτερο L2 miss rate (υποθέτοντας ότι κάνουν περίπου τις ίδιες πορσπελάσεις) έχουν πιο μεγάλη μείωση του χρόνου εκτέλεσης.

## Βήμα 2

Εδώ ζητείται η αλλαγή κάποιων παραμέτρων της ιεραρχίας μνήμης, ώστε το CPI των εντολών να προσεγγίζει το ιδανικό **1**.

* Αρχικά, παραθέτουμε διαγράμματα που δείχνουν την επίδραση κάθε παράγοντα ξεχωριστά στην απόδοση του κάθε Benchmark. Για τη δημιουργία αυτών, κρατάμε σταθερούς όλους τους υπόλοιπους παράγοντες στις default τιμές και μεταβάλλουμε κάθε φορά την παράμετρο που μας ενδιαφέρει.

![alt text](https://github.com/DimKon2001/ArchLab/blob/main/Lab2/plots/DL1-A.jpg)
![alt text](https://github.com/DimKon2001/ArchLab/blob/main/Lab2/plots/DL1-S.jpg)
![alt text](https://github.com/DimKon2001/ArchLab/blob/main/Lab2/plots/IL1-S.jpg)
![alt text](https://github.com/DimKon2001/ArchLab/blob/main/Lab2/plots/IL1-A.jpg)
![alt text](https://github.com/DimKon2001/ArchLab/blob/main/Lab2/plots/L2-A.jpg)
![alt text](https://github.com/DimKon2001/ArchLab/blob/main/Lab2/plots/L2-S.jpg)
![alt text](https://github.com/DimKon2001/ArchLab/blob/main/Lab2/plots/LS.jpg)

1. **bzip**
    Στο συγκεκριμένο benchmark παρατηρήθηκε πως με τις default τιμές το miss rate της instruction cache ήταν σχεδόν μηδενικό, 
    οπότε διατηρήθηκαν οι default τιμές ως προς το μέγεθος και τo associativity της. Στην συνέχεια διπλασιάστηκε και 
    υποδιπλασιάστηκε το μέγεθος του cache line, ενός παράγοντα που επηρεάζει και τους 3 τύπους cache misses της εργασίας. 
    Με διπλασιασμό του cache line για σταθερό μέγεθος cache βελτιώνεται το spatial locality του προγράμματος και μειώνονται 
    τα compulsory misses, αλλά αυξάνονται τα capacity misses, εξαιτίας του μεγαλύτερου μεγέθους των cache lines. 
    Εδώ παρατηρήθηκε πως με τα default cache sizes βελτιώθηκαν και τα 3 cache miss rates, οπότε το cache line size έγινε 128. 

    |  benchmarks        |system.cpu.cpi|system.cpu.dcache.overall_miss_rate::total|	system.cpu.icache.overall_miss_rate::total|	system.l2.overall_miss_rate::total|
    |:------------------:|:----------:|:-------:|:-------:|:-------|
    |bzip_DL1_S_64_LS_128|	1.666573	|0.014359	|0.000067	|0.173845|
    |bzip_DL1_S_64_LS_64 |	1.679650	|0.014798	|0.000077	|0.282163|

    
    
  
    Στην συνέχεια, το προβλήματα των misses για την data cache, την instruction cache και την l2 cache είναι ανεξάρτητα.

    |  benchmarks        |system.cpu.cpi|system.cpu.dcache.overall_miss_rate::total|	system.cpu.icache.overall_miss_rate::total|	system.l2.overall_miss_rate::total|
    |:------------------:|:----------:|:-------:|:-------:|:-------|
    |bzip_DL1_S_128_DL1_A_1	|1.617513	|0.009068	|0.000067	|0.284306|
    |bzip_DL1_S_128_DL1_A_2	|1.634732	|0.010771	|0.000067	|0.236030|
    |bzip_DL1_S_128_DL1_A_4	|1.626013	|0.009841	|0.000067	|0.260142|
    |bzip_DL1_S_128_DL1_A_8	|1.617513	|0.009068	|0.000067	|0.284306|
    |bzip_DL1_S_128_DL1_A_16|1.617513 |0.009068 |0.000067 |0.284306|
    |bzip_DL1_S_64_DL1_A_1	|1.643747	|0.012206	|0.000067	|0.206465|
    |bzip_DL1_S_64_DL1_A_2	|1.666573	|0.014359	|0.000067	|0.173845|
    |bzip_DL1_S_64_DL1_A_4	|1.649833	|0.012826	|0.000067	|0.195893|
    |bzip_DL1_S_64_DL1_A_8	|1.643747	|0.012206	|0.000067	|0.206465|
    |bzip_DL1_S_64_DL1_A_16 |1.643747 |0.012206 |0.000067 |0.206465|

Ελέχγοντας και τον συνολικό αριθμό των misses στην data cache επιλέχθηκε:

```
size=131072
assoc=8
```

Tέλος για την l2 cache.


|  benchmarks       |system.cpu.cpi|system.cpu.dcache.overall_miss_rate::total|	system.cpu.icache.overall_miss_rate::total|	system.l2.overall_miss_rate::total|
|------------------:|:-------:|:-------:|:-------:|:-------|
|bzip_L2_S_1_L2_A_1	|1.681008	|0.009068	|0.000067	|0.419381|
|bzip_L2_S_1_L2_A_2	|1.650592	|0.009070	|0.000067	|0.359686|
|bzip_L2_S_1_L2_A_4	|1.643458	|0.009070	|0.000067	|0.341216|
|bzip_L2_S_1_L2_A_8	|1.641576	|0.009071	|0.000067	|0.333352|
|bzip_L2_S_1_L2_A_16|	1.640234|	0.009071|	0.000067|	0.329016|
|bzip_L2_S_2_L2_A_1	|1.640652	|0.009069	|0.000067	|0.327909|
|bzip_L2_S_2_L2_A_2	|1.625099	|0.009068	|0.000067	|0.300075|
|bzip_L2_S_2_L2_A_4	|1.616975	|0.009067	|0.000067	|0.284854|
|bzip_L2_S_2_L2_A_8	|1.617513	|0.009068	|0.000067	|0.284306|
|bzip_L2_S_2_L2_A_16|	1.618032|	0.009068|	0.000067|	0.284324|
|bzip_L2_S_4_L2_A_1	|1.602512	|0.009062	|0.000067	|0.259208|
|bzip_L2_S_4_L2_A_2	|1.600258	|0.009050	|0.000067	|0.253120|
|bzip_L2_S_4_L2_A_4	|1.599761	|0.009050	|0.000067	|0.252853|
|bzip_L2_S_4_L2_A_8	|1.599575	|0.009058	|0.000067	|0.252290|
|bzip_L2_S_4_L2_A_16|	1.598536|	0.009066|	0.000067|0.251077|

Eδώ αν και φαίνεται το miss rate στην l2 να έχει αυξηθεί σε σχέση με την υλοποίηση, όπου έχει αλλάξει μόνο το cache line size σε 128, στην πραγματικότητα αυτή
η αύξηση οφείλεται στο γεγονός ότι υπάρχουν λιγότερα misses στην data cache, οπότε λιγότερες φορές αναζητείται κάτι στην l2. Δηλαδή έχω λιγότερα l2 misses αν και σε ποσοστό είναι περισσότερα.

Το κόστος για την αύξηση του line size είναι σχεδόν μηδενικό, οπότε επιλέγεται ξανά line_size = 128, όμως για την dcache παρατηρείται πως δεν
απαιτείται associativity 8, αλλά πως και το associativity 1 δίνει το ίδιο CPI χωρίς να απαιτεί συγκριτές.
Τέλος με χρήση l2 cache 2MB με associativity 4 το κόστος για την l2 είναι λιγότερο από το 1/2, ενώ το cpi είναι μόνο 2% λιγότερο σε σχέση με την ακριβή υλοποίηση.

2. **mcf**
    Στο συγκεκριμένο benchmark παρατηρήθηκε πως με τις default τιμές το miss rate της instruction cache ήταν αρκετά μεγάλο.

    spec_results/specmcf_LS_128	1.330534	0.066527	281.87	**0.001384**	0.035212	0.020416
    spec_results/specmcf_LS_64	1.299095	0.064955	298.18	0.002108	0.023612	0.055046
    spec_results/specmcf_LS_32	1.260085	0.063004	295.74	0.003208	**0.013171**	0.159189

    Λόγω της αντιστρόφως ανάλογης σχέσης μεταξύ ls icache miss rate και dcache miss rate
    Για την μείωση του icache miss rate διπλασιάστηκε η icache και επιλέχθηκε line size = 128

    spec_results/specmcf_LS_128_DL1_S_128_IL1_S_64	1.123502	0.056175	261.41	**0.001180**	**0.000020**	0.624600
    spec_results/specmcf_LS_32_DL1_S_128_IL1_S_64	1.178559	0.058928	272.66	0.003043	0.000026	0.869800
    spec_results/specmcf_LS_64_DL1_S_128_IL1_S_64	1.155171	0.057759	271.56	0.001932	0.000018	0.776058
    spec_results/specmcf_LS_16_DL1_S_128_IL1_S_64	1.314712	0.065736	277.74	0.004511	0.000035	0.918531

    Eπειδή το miss rate σχεδόν εκμηδενίστηκε οι υπόλοιποι παράγοντες της icache έμειναν σταθεροί.

    Στην συνέχεια για την εύρεση του associativity
spec_results/specmcf_DL1_A_4_S_128_IL1_A_2_S_64_LS_128	1.329491	0.066475	292.68	0.001120	0.035257	0.020533
spec_results/specmcf_DL1_A_1_S_128_IL1_A_2_S_64_LS_128	1.333098	0.066655	285.10	0.001772	0.035206	0.020180
spec_results/specmcf_DL1_A_16_S_128_IL1_A_2_S_64_LS_128	1.329359	0.066468	284.06	0.001104	0.035257	0.020538
spec_results/specmcf_DL1_A_8_S_128_IL1_A_2_S_64_LS_128	1.329424	0.066471	302.41	0.001106	0.035256	0.020539
spec_results/specmcf_DL1_A_2_S_128_IL1_A_2_S_64_LS_128	1.329652	0.066483	308.67	0.001180	0.035247	0.020510


    

3. **jeng**

Mε αύξηση του line size σε 128 παρατηρήθηκε μεγάλη μείωση στο CPI με πολύ μικρό κόστος, ενώ το miss rate στην instruction cache
σχεδόν εκμηδενίστηκε, οπότε η instruction cache διατηρήθηκε στις default τιμές.

μένει το line size 64
|  benchmarks       |system.cpu.cpi|system.cpu.dcache.overall_miss_rate::total|	system.cpu.icache.overall_miss_rate::total|	system.l2.overall_miss_rate::total|
|------------------:|:-------:|:-------:|:-------:|:-------|
|jeng_LS_32	        |17.653706	|0.243654	|0.000023	|0.999988|
|jeng_LS_128        |	6.799471	|0.060922	|0.000015	|0.999825|

Για την dcache παρατηρήθηκε ότι το associativity πάνω από 2 και dcache size δεν είχαν επίδραση στο CPI


spec_results/specsjeng_DL1_S_32_DL1_A_2_LS_128	6.799471	0.339974	501.58	0.060926	0.000015	0.999686
spec_results/specsjeng_DL1_S_32_DL1_A_4_LS_128	6.799674	0.339984	501.91	0.060918	0.000015	0.999942
spec_results/specsjeng_DL1_S_32_DL1_A_8_LS_128	6.799674	0.339984	516.35	0.060918	0.000015	0.999945

spec_results/specsjeng_DL1_S_64_DL1_A_2_LS_128	6.799471	0.339974	505.23	0.060922	0.000015	0.999825
spec_results/specsjeng_DL1_S_64_DL1_A_4_LS_128	6.799536	0.339977	541.99	0.060918	0.000015	0.999949
spec_results/specsjeng_DL1_S_64_DL1_A_8_LS_128	6.799674	0.339984	558.96	0.060918	0.000015	0.999949

spec_results/specsjeng_DL1_S_128_DL1_A_2_LS_128	6.799362	0.339968	505.99	0.060921	0.000015	0.999856
spec_results/specsjeng_DL1_S_128_DL1_A_4_LS_128	6.799362	0.339968	502.81	0.060918	0.000015	0.999952
spec_results/specsjeng_DL1_S_128_DL1_A_8_LS_128	6.799609	0.339980	490.68	0.060918	0.000015	0.999952



Για πιο οικονομική κατασκευή παρατηρήθηκε πως μια direct mapped 32kb dcache είχε system.cpu.cpi = 6.834823.

Mένει το l2


4. **hmmer**



5. **lbm**

